---
title: HDLBits tutorial
author: Three Month
date: 2023-06-15
category: Jekyll
layout: post
---

## Getting Started
### Getting Started
Website: <a href="https://hdlbits.01xz.net/wiki/Step_one" target="_blank">https://hdlbits.01xz.net/wiki/Step_one</a>

這題是教你怎麼操作平台的，然後要對one輸出1。這裡有個細節是給值時盡量寫的清楚一點，像這裡1bit，就可以不是只給1，而是給1'b1。
```verilog
module top_module( output one );
    assign one = 1'b1;
endmodule
```
---
### Output Zero
Website: <a href="https://hdlbits.01xz.net/wiki/Zero" target="_blank">https://hdlbits.01xz.net/wiki/Zero</a>

這題跟上題大同小異，只是換成輸出0。
```verilog
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 1'b0;
endmodule
```
---
## Verilog Language
### Basics
#### Simple wire
Website: <a href="https://hdlbits.01xz.net/wiki/Wire" target="_blank">https://hdlbits.01xz.net/wiki/Wire</a>

這題就是簡單的把out和in接在一起。
```verilog
module top_module( input in, output out );
	assign out = in;
endmodule
```
---
#### Four wires
Website: <a href="https://hdlbits.01xz.net/wiki/Wire4" target="_blank">https://hdlbits.01xz.net/wiki/Wire4</a>

這題就照著圖接線，w和a相接，xy和b相接，z和c相接。
```verilog
module top_module( 
    input a,b,c,
    output w,x,y,z );
	assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule
```
---
#### Inverter
Website: <a href="https://hdlbits.01xz.net/wiki/Notgate" target="_blank">https://hdlbits.01xz.net/wiki/Notgate</a>

這題要寫一個not gate。  
值得注意的是，verilog中有分bitwise operator和logical operator，bitwise operator就是對input的每個bit都做相對的運算，所以最後輸出的bit數會跟input一樣。而logical operator只會邏輯上做運算，最後只會輸出1 bit。   
所以說bitwise not符號是```~```，而logical not符號是```!```，雖然這題input只有1 bit沒差，不過細節可能要注意。
```verilog
module top_module( input in, output out );
	assign out = ~in;
endmodule
```
---
#### AND gate
Website: <a href="https://hdlbits.01xz.net/wiki/Andgate" target="_blank">https://hdlbits.01xz.net/wiki/Andgate</a>

這題就刻一個and gate，跟上題差不多，要注意的是bitwise and符號是```&```，而logical and符號是```&&```，
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
	assign out = a & b;
endmodule
```
---
#### NOR gate
Website: <a href="https://hdlbits.01xz.net/wiki/Norgate" target="_blank">https://hdlbits.01xz.net/wiki/Norgate</a>

這題就刻一個nor gate，跟上題差不多，要注意的是bitwise or符號是```~```，而logical and符號是```~~```，
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule
```
---
#### XNOR gate
Website: <a href="https://hdlbits.01xz.net/wiki/Xnorgate" target="_blank">https://hdlbits.01xz.net/wiki/Xnorgate</a>

這題就刻一個xnor gate，跟上題差不多，要注意的是bitwise xor符號是```^```，而verilog中沒有logical xor運算。
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule
```
---
#### Declaring wires
Website: <a href="https://hdlbits.01xz.net/wiki/Wire_decl" target="_blank">https://hdlbits.01xz.net/wiki/Wire_decl</a>

這題引入了wire的概念，wire就是在線路複雜時，提供節點來幫助閱讀。補充一下，input和output本身就是wire。
```verilog
`default_nettype none
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out,
    output out_n   ); 
	wire a_and_b, c_and_d;
    assign a_and_b = a & b;
    assign c_and_d = c & d;
    assign out = a_and_b | c_and_d;
    assign out_n = ~out;
endmodule
```
---
#### 7458 chip
Website: <a href="https://hdlbits.01xz.net/wiki/7458" target="_blank">https://hdlbits.01xz.net/wiki/7458</a>

這題跟上題類似，就是線路稍微複雜，可以直接寫，也可以使用wire幫助閱讀。
```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);
    assign p2y = (p2a & p2b) | (p2c & p2d);
endmodule
```
---
### Vectors
#### Vectors
Website: <a href="https://hdlbits.01xz.net/wiki/Vector0" target="_blank">https://hdlbits.01xz.net/wiki/Vector0</a>

這題是將[2:0] vec分別賦值給[2:0] outv和{o2,o1,o0}，補充說明，```assign {o2,o1,o0} = vec;```等價於```assign o2 = vec[2]; assign o1 = vec[1]; assign o0 = vec[0];```。

```verilog
module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign outv = vec;
    assign {o2,o1,o0} = vec;
endmodule
```
---
#### Vectors in more detail
Website: <a href="https://hdlbits.01xz.net/wiki/Vector1" target="_blank">https://hdlbits.01xz.net/wiki/Vector1</a>

跟上題大同小異，```assign {out_hi,out_lo} = in;```等價於```assign out_hi = in[15:8]; assign out_lo = in[7:0];```。
```verilog
`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign {out_hi,out_lo} = in;
endmodule
```
---
#### Vector part select
Website: <a href="https://hdlbits.01xz.net/wiki/Vector2" target="_blank">https://hdlbits.01xz.net/wiki/Vector2</a>

跟上題大同小異，```assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};```等價於```	assign out[31:24] = in[ 7: 0]; assign out[23:16] = in[15: 8]; assign out[15: 8] = in[23:16]; assign out[ 7: 0] = in[31:24];```。
```verilog
module top_module( 
    input [31:0] in,
    output [31:0] out );
    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};
endmodule
```
---
#### Bitwise operators
Website: <a href="https://hdlbits.01xz.net/wiki/Vectorgates" target="_blank">https://hdlbits.01xz.net/wiki/Vectorgates</a>

這題主要講述bitwise operators和logical operators的差異。像說bitwise or的符號為```|```，logical or的符號為```||```，bitwise not的符號為```~```，logical not的符號為```!```。這題的not是bitwise not，不要弄混了。
```verilog
module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
	assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not = ~ {b,a};
endmodule
```
---
#### Four-input gates
Website: <a href="https://hdlbits.01xz.net/wiki/Gates4" target="_blank">https://hdlbits.01xz.net/wiki/Gates4</a>

這題在複習各種gate的用法。
```verilog
module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = in[3] & in[2] & in[1] & in[0];
    assign out_or = in[3] | in[2] | in[1] | in[0];
    assign out_xor = in[3] ^ in[2] ^ in[1] ^ in[0];
endmodule
```

#### Vector concatenation operator
Website: <a href="https://hdlbits.01xz.net/wiki/Vector3" target="_blank">https://hdlbits.01xz.net/wiki/Vector3</a>

這題在教concatenation的概念，然後因為題目要求要padding11在最右邊2bits，所以要加上2'b11。
```verilog
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z} = {a,b,c,d,e,f,2'b11};

endmodule
```
---
#### Vector reversal 1
Website: <a href="https://hdlbits.01xz.net/wiki/Vectorr" target="_blank">https://hdlbits.01xz.net/wiki/Vectorr</a>

這題當然能用concatenation的概念完成，當然如果想寫個類似for loop的方法連線，可以參考generate語法。
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
	generate
		genvar i;
		for (i=0; i<8; i = i+1) begin: my_block_name
			assign out[i] = in[8-i-1];
		end
	endgenerate
endmodule
```
---
#### Replication operator
Website: <a href="https://hdlbits.01xz.net/wiki/Vector4" target="_blank">https://hdlbits.01xz.net/wiki/Vector4</a>

這題將8bit轉成32bit，並且多餘的24bit要填入in[7]，所以語法如下。
```verilog
module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = { { 24{ in[7] } },in};

endmodule
```
---
#### More replication
Website: <a href="https://hdlbits.01xz.net/wiki/Vector5" target="_blank">https://hdlbits.01xz.net/wiki/Vector5</a>

這題也是練習replication，aaaaabbbbbcccccdddddeeeee可以寫成```{ {5{a}},{5{b}},{5{c}},{5{d}},{5{e}}}```，abcdeabcdeabcdeabcdeabcde可以寫成```{5{a,b,c,d,e}}```。
```verilog
module top_module (
    input a, b, c, d, e,
    output [24:0] out );//
    assign out = ~({ { 5{a} },{5{b}},{5{c}},{5{d}},{5{e}}} ^ {5{a,b,c,d,e}});
endmodule
```
---

### Modules: Hierarchy
#### Modules
Website: <a href="https://hdlbits.01xz.net/wiki/Module" target="_blank">https://hdlbits.01xz.net/wiki/Module</a>

這題在教如何引用module。
```verilog
module top_module ( input a, input b, output out );
    mod_a moda(.out(out),.in1(a),.in2(b));
endmodule
```
---
#### Connecting ports by position
Website: <a href="https://hdlbits.01xz.net/wiki/Module_pos" target="_blank">https://hdlbits.01xz.net/wiki/Module_pos</a>

這題跟上題差不多，題目要求我們照著argument的位置接線。
```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    module mod_a ( out1, out2, a, b, c, d );
endmodule
```
---
#### Connecting ports by name
Website: <a href="https://hdlbits.01xz.net/wiki/Module_name" target="_blank">https://hdlbits.01xz.net/wiki/Module_name</a>

這題跟上題差不多，只是上題是要求根據argument的位置接線，這題是要求跟據argument的名字接線。
```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a moda(.out1(out1), .out2(out2), .in1(a), .in2(b), .in3(c), .in4(d));
endmodule
```
---
#### Three modules
Website: <a href="https://hdlbits.01xz.net/wiki/Module_shift" target="_blank">https://hdlbits.01xz.net/wiki/Module_shift</a>

這題是練習用接線的方式，將3個dff串接在一起。
```verilog
module top_module ( input clk, input d, output q );
    wire q1,q2;
    my_dff dff1( .clk(clk), .d(d), .q(q1));
    my_dff dff2( .clk(clk), .d(q1), .q(q2));
    my_dff dff3( .clk(clk), .d(q2), .q(q));
endmodule
```
---
#### Modules and vectors
Website: <a href="https://hdlbits.01xz.net/wiki/Module_shift8" target="_blank">https://hdlbits.01xz.net/wiki/Module_shift8</a>

這題跟上題差不多，只是後面多接了一個multiplexer。而multiplexer可以用always block實現，速度會比用if else還快，而因為multiplexer是combinational logic，所以要用blocking assignments。

```verilog
module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    wire [7:0]q1,q2,q3;
    my_dff8 dff1( .clk(clk), .d(d), .q(q1));
    my_dff8 dff2( .clk(clk), .d(q1), .q(q2));
    my_dff8 dff3( .clk(clk), .d(q2), .q(q3));
    always @(*)
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
endmodule
```
---
#### Adder 1
Website: <a href="https://hdlbits.01xz.net/wiki/Module_add" target="_blank">https://hdlbits.01xz.net/wiki/Module_add</a>

這題單純把兩個16bit adder接在一起，值得注意的是，如果argument不想接線，直接留空就行了。
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire c1;
    add16 add_1( .a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(c1));
    add16 add_2( .a(a[31:16]), .b(b[31:16]), .cin(c1), .sum(sum[31:16]), .cout());
endmodule
```
---
#### Adder 2
Website: <a href="hhttps://hdlbits.01xz.net/wiki/Module_fadd" target="_blank">https://hdlbits.01xz.net/wiki/Module_fadd</a>

這題跟上題差不多，只是要多寫一個1 bit full adder，可以用concatenation來實現。
```verilog
module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
	wire c1;
    add16 add_1( .a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(c1));
    add16 add_2( .a(a[31:16]), .b(b[31:16]), .cin(c1), .sum(sum[31:16]), .cout());
endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );
    assign {cout, sum} = a + b + cin;
endmodule
```
---
#### Carry-select adder
Website: <a href="https://hdlbits.01xz.net/wiki/Module_cseladd" target="_blank">https://hdlbits.01xz.net/wiki/Module_cseladd</a>

這題要我們接線CSA(carry-select adder)，CSA的好處在於已經偷算完cin是0和1的case，等到低位元進位後，就能馬上用multiplexer輸出算好的結果，缺點就是因為同時要算cin是0和1的結果，面積會變兩倍。
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);	
    wire sel;
    wire [15:0] s1,s2;
    add16 add1( .a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(sel));
    add16 add2( .a(a[31:16]), .b(b[31:16]), .cin(1'b0), .sum(s1), .cout());
    add16 add3( .a(a[31:16]), .b(b[31:16]), .cin(1'b1), .sum(s2), .cout());
    always @(*)
		case(sel)
        	1'b0: sum[31:16] = s1;
            1'b1: sum[31:16] = s2;
       	endcase
endmodule
```
---
#### Adder-subtractor
Website: <a href="https://hdlbits.01xz.net/wiki/Module_addsub" target="_blank">https://hdlbits.01xz.net/wiki/Module_addsub</a>

這題在教如何快速實現減法，也就是```a - b = a + ~(b) + 1```這件事。
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire c1;
    wire [31:0] b_xor;
    assign b_xor = b ^ {32{sub}};
    add16 add_1( .a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .sum(sum[15:0]), .cout(c1));
    add16 add_2( .a(a[31:16]), .b(b_xor[31:16]), .cin(c1), .sum(sum[31:16]), .cout());
endmodule
```
---
### Procedures
#### Always blocks (combinational)
Website: <a href="https://hdlbits.01xz.net/wiki/Alwaysblock1" target="_blank">https://hdlbits.01xz.net/wiki/Alwaysblock1</a>

這題在講說combinational logic可以有assign和always @(*)兩種寫法。然後有個細節要注意，assign的左值要用wire，always的左值要用reg，雖然這兩者在合成電路後沒差。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
	assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule
```
---
#### Always blocks (clocked)
Website: <a href="https://hdlbits.01xz.net/wiki/Alwaysblock2" target="_blank">https://hdlbits.01xz.net/wiki/Alwaysblock2</a>

這題就是在講combinational logic和sequential logic的差別。如果是clock always的話，最好賦值使用non-blocking。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
	assign out_assign = a ^ b;
    always@(*)
        out_always_comb = a ^ b;
    always@(posedge clk)
        out_always_ff <= a ^ b;
endmodule
```
---
#### If statement
Website: <a href="https://hdlbits.01xz.net/wiki/Always_if" target="_blank">https://hdlbits.01xz.net/wiki/Always_if</a>

這題分別要求要寫三元運算和在combinational block中寫if/else，可能要注意的是cond可以共用。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 
    wire cond;
    assign cond = sel_b1 & sel_b2;
    assign out_assign = cond ? b : a;
    always@(*)begin
        if(cond)begin
            out_always = b;
        end
        else begin
        	out_always = a;
        end
    end 
endmodule
```
---
#### If statement latches
Website: <a href="https://hdlbits.01xz.net/wiki/Always_if2" target="_blank">https://hdlbits.01xz.net/wiki/Always_if2</a>

這題在講說要寫清楚else和default，不然verilog會合成出latch。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input      cpu_overheated,
    output reg shut_off_computer,
    input      arrived,
    input      gas_tank_empty,
    output reg keep_driving  ); //

    always @(*) begin
        if (cpu_overheated)
           shut_off_computer = 1;
        else
           shut_off_computer = 0;
    end

    always @(*) begin
        if (~arrived)
           keep_driving = ~gas_tank_empty;
        else
           keep_driving = 1'b0;
    end

endmodule
```
---
#### Case statement
Website: <a href="https://hdlbits.01xz.net/wiki/Always_case" target="_blank">https://hdlbits.01xz.net/wiki/Always_case</a>

這題在教case如何使用，然後要記得寫default防止latch。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule
```
---
#### Priority encoder
Website: <a href="https://hdlbits.01xz.net/wiki/Always_case2" target="_blank">https://hdlbits.01xz.net/wiki/Always_case2</a>

這題要寫一個encoder，我看了卡諾圖後，發現用if else或卡諾圖畫的沒什麼太大的差異，卡諾圖的gate level少了一點，但是gate多了一些，所以這題練習用if else寫。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    always@(*)begin
        if(in[0]) pos = 2'b00;
        else if(in[1]) pos = 2'b01;
        else if(in[2]) pos = 2'b10;
        else if(in[3]) pos = 2'b11;
        else pos= 2'b00;
    end
endmodule
```
---
#### Priority encoder with casez
Website: <a href="https://hdlbits.01xz.net/wiki/Always_casez" target="_blank">https://hdlbits.01xz.net/wiki/Always_casez</a>

這題跟上題差不多，只是嘗試用casez實作encoder。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always@(*)begin
        casez(in)
            8'bzzzzzzz1: pos = 3'b000;
            8'bzzzzzz10: pos = 3'b001;
            8'bzzzzz100: pos = 3'b010;
            8'bzzzz1000: pos = 3'b011;
            8'bzzz10000: pos = 3'b100;
            8'bzz100000: pos = 3'b101;
            8'bz1000000: pos = 3'b110;
            8'b10000000: pos = 3'b111;
            default: 	 pos = 3'b000;
        endcase
    end
endmodule
```
---
#### Avoiding latches
Website: <a href="https://hdlbits.01xz.net/wiki/Always_nolatches" target="_blank">https://hdlbits.01xz.net/wiki/Always_nolatches</a>

這題在練習如何在有大量output情形時，透過預先寫默認的輸入來減少行數，而這種寫法對於合成電路沒什麼影響，因為實際的電路不是照著程式碼一行一行執行。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    always@(*)begin
        up = 1'b0;
        down = 1'b0;
        left = 1'b0;
        right =1'b0;
        case(scancode)
            16'he06b: left= 1'b1;
			16'he072: down= 1'b1;
			16'he074: right= 1'b1;
			16'he075: up= 1'b1;
        endcase
    end
endmodule
```
---
### More Verilog Features
#### Conditional ternary operator
Website: <a href="https://hdlbits.01xz.net/wiki/Conditional" target="_blank">https://hdlbits.01xz.net/wiki/Conditional</a>

這題在教三元運算的使用。題目說要做一個4-to-1 MUX，可以簡單用3個2元運算接出電路。
```verilog
module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//
	
    // assign intermediate_result1 = compare? true: false;
    wire [7:0]w1,w2;
    assign w1 = (a<b)? a : b;
    assign w2 = (c<d)? c : d;
    assign min = (w1<w2)? w1 : w2;
endmodule
```
---
#### Reduction operators
Website: <a href="https://hdlbits.01xz.net/wiki/Reduction" target="_blank">https://hdlbits.01xz.net/wiki/Reduction</a>

這題練習reduction operator，透過```assign parity =^in```，省去了冗長的in運算。
```verilog
module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^in;
endmodule
```
---
#### Reduction: Even wider gates
Website: <a href="https://hdlbits.01xz.net/wiki/Gates100" target="_blank">https://hdlbits.01xz.net/wiki/Gates100</a>

這題跟上題差不多，只是位數變多了。
```verilog
module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
	assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;
endmodule
```
---
#### Combinational for-loop: Vector reversal 2
Website: <a href="https://hdlbits.01xz.net/wiki/Vector100r" target="_blank">https://hdlbits.01xz.net/wiki/Vector100r</a>

這題教程推薦用always block來實作reversal，就可以不用寫generate了。
```verilog
module top_module( 
    input [99:0] in,
    output [99:0] out
);
	integer i;
    always@(*)begin
        for(i=0;i<100;i++)begin
            out[i] = in[99-i];
        end
    end
endmodule
```
---
#### Combinational for-loop: 255-bit population count
Website: <a href="https://hdlbits.01xz.net/wiki/Popcount255" target="_blank">https://hdlbits.01xz.net/wiki/Popcount255</a>

這題要算陣列中元素的數量，可以用for loop來實現，然後記得out要初始化為0。
```verilog
module top_module( 
    input [254:0] in,
    output [7:0] out );
    integer i;
    always@(*)begin
        out = 8'b00000000;
        for(i=0;i<255;i++)begin
            out = out + in[i];
        end
    end
endmodule
```
---
#### Generate for-loop: 100-bit binary adder 2
Website: <a href="https://hdlbits.01xz.net/wiki/Adder100i" target="_blank">https://hdlbits.01xz.net/wiki/Adder100i</a>

這題在練習100bit的加法，因為題目要求用module實作1bit full adder，所以這裡只能用generate初始化。
```verilog
module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    full_adder fa_first(.a(a[0]),.b(b[0]),.cin(cin),.cout(cout[0]),.sum(sum[0]));
    
	genvar i;
    generate
        for(i=1;i<100;i++)begin: block_name
            full_adder fa(.a(a[i]),.b(b[i]),.cin(cout[i-1]),.cout(cout[i]),.sum(sum[i]));
        end
    endgenerate
endmodule

module full_adder(input a,input b,input cin,output cout,output sum);
    assign {cout,sum} = a + b + cin;
endmodule
```
---
#### Generate for-loop: 100-digit BCD adder
Website: <a href="https://hdlbits.01xz.net/wiki/Bcdadd100" target="_blank">https://hdlbits.01xz.net/wiki/Bcdadd100</a>

這題跟上題差不多，只是將adder變成了BCD-adder。
```verilog
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [99:0]w;
    assign cout = w[99];
    bcd_fadd bcd_fadd_first(.a(a[3:0]),.b(b[3:0]),.cin(cin),.cout(w[0]),.sum(sum[3:0]));

    genvar i;
    generate
        for(i=1;i<100;i++)begin:block_bcd
            bcd_fadd bf(.a(a[4*i+3:4*i]),.b(b[4*i+3:4*i]),.cin(w[i-1]),.cout(w[i]),.sum(sum[4*i+3:4*i]));
        end
    endgenerate
endmodule
```
---
## Circuits
### Combinational Logic
#### Basic Gates
##### Wire
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4h" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4h</a>

這題就單純接線。
```verilog
module top_module (
    input in,
    output out);
	assign out = in;
endmodule
```
---
##### GND
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4i" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4i</a>

這題就單純接線。
```verilog
module top_module (
    output out);
	assign out = 1'b0;
endmodule
```
---
##### NOR
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4e" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4e</a>

這題就單純接線。
```verilog
module top_module (
    input in1,
    input in2,
    output out);
    assign out = ~ (in1 | in2);
endmodule
```
---
##### Another gate
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4f" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4f</a>

這題就單純接線。
```verilog
module top_module (
    input in1,
    input in2,
    output out);
    assign out = in1 & (~in2);
endmodule
```
---
##### Two gates
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4g" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4g</a>

這題就單純接線。
```verilog
module top_module (
    input in1,
    input in2,
    input in3,
    output out);
    assign out = (~(in1 ^ in2))^ in3;
endmodule
```
---
##### More logic gates
Website: <a href="https://hdlbits.01xz.net/wiki/Gates" target="_blank">https://hdlbits.01xz.net/wiki/Gates</a>

這題考各種gate的運算。
```verilog
module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
	assign out_and   = a & b;
    assign out_or    = a | b;
    assign out_xor   = a ^ b;
    assign out_nand  = ~(a & b);
    assign out_nor   = ~(a | b);
    assign out_xnor  = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule
```
---
##### 7420 chip
Website: <a href="https://hdlbits.01xz.net/wiki/7420" target="_blank">https://hdlbits.01xz.net/wiki/7420</a>

這題考稍微複雜的接線。
```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);
endmodule
```
---
##### Truth tables
Website: <a href="https://hdlbits.01xz.net/wiki/Truthtable1" target="_blank">https://hdlbits.01xz.net/wiki/Truthtable1</a>

這題給了真值表，可以進一步使用卡諾圖化簡。
```verilog
module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x1) | ((~x3) & x2);
endmodule
```
---
##### Two-bit equality
Website: <a href="https://hdlbits.01xz.net/wiki/Mt2015_eq2" target="_blank">https://hdlbits.01xz.net/wiki/Mt2015_eq2</a>

這題用三元運算子就能解決。
```verilog
module top_module ( input [1:0] A, input [1:0] B, output z ); 
    assign z = (A == B)? 1'b1: 1'b0;
endmodule
```
---
##### Simple circuit A
Website: <a href="https://hdlbits.01xz.net/wiki/Mt2015_q4a" target="_blank">https://hdlbits.01xz.net/wiki/Mt2015_q4a</a>

這題照題目assign就行，如果從類比層面來看，not gate會比and，or，xor還小，強烈推薦多化簡成not gate。
```verilog
module top_module (input x, input y, output z);
    assign  z = x & (~y);
endmodule
```
---
##### Simple circuit B
Website: <a href="https://hdlbits.01xz.net/wiki/Mt2015_q4b" target="_blank">https://hdlbits.01xz.net/wiki/Mt2015_q4b</a>

這題透過觀察波形，寫出組合邏輯。
```verilog
module top_module ( input x, input y, output z );
    assign z = ~(x ^ y);
endmodule
```
---
##### Combine circuits A and B
Website: <a href="https://hdlbits.01xz.net/wiki/Mt2015_q4" target="_blank">https://hdlbits.01xz.net/wiki/Mt2015_q4</a>

這題只是將上兩題當作當作submodule後接線。
```verilog
module top_module (input x, input y, output z);
	wire wa1,wa2,wb1,wb2;
    A IA1(.x(x), .y(y), .z(wa1));
    A IA2(.x(x), .y(y), .z(wa2));
    B IB1(.x(x), .y(y), .z(wb1));
    B IB2(.x(x), .y(y), .z(wb2));
    assign z = ( wa1 | wb1 ) ^ ( wa2  & wb2 );
endmodule

module A (input x, input y, output z);
    assign  z = x & (~y);
endmodule

module B ( input x, input y, output z );
    assign z = ~(x ^ y);
endmodule
```
---
##### Ring or vibrate?
Website: <a href="https://hdlbits.01xz.net/wiki/Ringer" target="_blank">https://hdlbits.01xz.net/wiki/Ringer</a>

這題題目要求用gate寫出符合敘述的邏輯。
```verilog
module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    assign motor = ring & vibrate_mode;
    assign ringer = ring & (~vibrate_mode);
endmodule
```
---
##### Thermostat
Website: <a href="https://hdlbits.01xz.net/wiki/Thermostat" target="_blank">https://hdlbits.01xz.net/wiki/Thermostat</a>

這題跟上題差不多，就是照著條件接出對應的電路。
```verilog
module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
	assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = heater | aircon | fan_on;
endmodule
```
---
##### 3-bit population count
Website: <a href="https://hdlbits.01xz.net/wiki/Popcount3" target="_blank">https://hdlbits.01xz.net/wiki/Popcount3</a>

這題就是寫個全加器。
```verilog
module top_module( 
    input [2:0] in,
    output [1:0] out );
    assign out = in[2] + in[1] + in[0];
endmodule
```
---
##### Gates and vectors
Website: <a href="https://hdlbits.01xz.net/wiki/Gatesv" target="_blank">https://hdlbits.01xz.net/wiki/Gatesv</a>

這題就是練習assign一排運算。
```verilog
module top_module( 
    input [3:0] in,
    output [2:0] out_both,
    output [3:1] out_any,
    output [3:0] out_different );
    assign out_both = in[2:0] & in[3:1];
    assign out_any = in[2:0] | in[3:1];
    assign out_different = in [3:0] ^ {in[0],in[3:1]};
endmodule
```
---
##### Even longer vectors
Website: <a href="https://hdlbits.01xz.net/wiki/Gatesv100" target="_blank">https://hdlbits.01xz.net/wiki/Gatesv100</a>

這題跟上題差不多，只是input vector變長了。
```verilog
module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    assign out_both = in[98:0] & in[99:1];
    assign out_any = in[98:0] | in[99:1];
    assign out_different = in [99:0] ^ {in[0],in[99:1]};
endmodule
```
---
#### Multiplexers
##### 2-to-1 multiplexer
Website: <a href="https://hdlbits.01xz.net/wiki/Mux2to1" target="_blank">https://hdlbits.01xz.net/wiki/Mux2to1</a>

用三元運算子就能輕鬆寫出multiplexer。
```verilog
module top_module( 
    input a, b, sel,
    output out ); 
	assign out = sel? b: a;
endmodule
```
---
##### 2-to-1 bus multiplexer
Website: <a href="https://hdlbits.01xz.net/wiki/Mux2to1v" target="_blank">https://hdlbits.01xz.net/wiki/Mux2to1v</a>

跟上題差不多，用三元運算子就能輕鬆寫出vector的multiplexer。
```verilog
module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
	assign out = sel ? b : a;
endmodule
```
---
##### 9-to-1 multiplexer
Website: <a href="https://hdlbits.01xz.net/wiki/Mux9to1v" target="_blank">https://hdlbits.01xz.net/wiki/Mux9to1v</a>

這題可以用case來實現9-to-1 multiplexer。
```verilog
module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    always@(*)begin
        case(sel)
            4'b0000: out = a;
			4'b0001: out = b;
            4'b0010: out = c;
            4'b0011: out = d;
            4'b0100: out = e;
            4'b0101: out = f;
            4'b0110: out = g;
            4'b0111: out = h;
            4'b1000: out = i;
            default: out = {16{1'b1}};
        endcase
    end
endmodule
```
---
##### 256-to-1 multiplexer
Website: <a href="https://hdlbits.01xz.net/wiki/Mux256to1" target="_blank">https://hdlbits.01xz.net/wiki/Mux256to1</a>

這題講述sel也可以放在index的位置。
```verilog
module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    assign out = in[sel];
endmodule
```
---
##### 256-to-1 4-bit multiplexer
Website: <a href="https://hdlbits.01xz.net/wiki/Mux256to1v" target="_blank">https://hdlbits.01xz.net/wiki/Mux256to1v</a>

題目講說```assign out = in[4*sel+3 :4*sel];```會編不過，所以可以改寫成```assign out = in[4*sel +:4];```，從4*sel的地方往上取4位。
```verilog
module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    assign out = in[4*sel +:4];
endmodule
```
---
#### Arithmetic Circuits
##### Half adder
Website: <a href="https://hdlbits.01xz.net/wiki/Hadd" target="_blank">https://hdlbits.01xz.net/wiki/Hadd</a>

這題就是寫一個半加器。
```verilog
module top_module( 
    input a, b,
    output cout, sum );
	assign cout = a & b;
    assign sum = a ^ b;
endmodule
```
---
##### Full adder
Website: <a href="https://hdlbits.01xz.net/wiki/Fadd" target="_blank">https://hdlbits.01xz.net/wiki/Fadd</a>

這題就是寫一個全加器。
```verilog
module top_module( 
    input a, b, cin,
    output cout, sum );
    assign {cout,sum} = a + b + cin;
endmodule
```
---
##### 3-bit binary adder
Website: <a href="https://hdlbits.01xz.net/wiki/Adder3" target="_blank">https://hdlbits.01xz.net/wiki/Adder3</a>

這題就是將3個全加器串在一起。
```verilog
module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    FA FA1(.a(a[0]),.b(b[0]),.cin(cin),.cout(cout[0]),.sum(sum[0]));
    FA FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.cout(cout[1]),.sum(sum[1]));
    FA FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.cout(cout[2]),.sum(sum[2]));
endmodule

module FA( 
    input a, b, cin,
    output cout, sum );
    assign {cout,sum} = a + b + cin;
endmodule
```
---
##### Adder
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4j" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4j</a>

這題就是將4個全加器串在一起，順便練習用generate block寫了for loop。
```verilog
module top_module (
    input [3:0] x,
    input [3:0] y, 
    output [4:0] sum);
    wire [4:1]cout;
    assign sum[4] = cout[4];
    FA FAA(.a(x[0]),.b(y[0]),.cin(1'b0),.cout(cout[1]),.sum(sum[0]));
    genvar i;
    generate
        for(i=1;i<4;i++)begin:block
            FA FAA(.a(x[i]),.b(y[i]),.cin(cout[i]),.cout(cout[i+1]),.sum(sum[i]));
        end
    endgenerate
endmodule

module FA( 
    input a, b, cin,
    output cout, sum );
    assign {cout,sum} = a + b + cin;
endmodule
```
---
##### Signed addition overflow
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q1c" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q1c</a>

這題單純練習overflow的判別，也就是兩正數相加或兩負數相減時，分別得到負數和正數，那就是發生overflow。
```verilog
module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
);
    assign s = a + b;
    assign overflow = (a[7]&b[7]&(~s[7])) | ((~a[7])&(~b[7])&s[7]);
endmodule
```
---
##### 100-bit binary adder
Website: <a href="https://hdlbits.01xz.net/wiki/Adder100" target="_blank">https://hdlbits.01xz.net/wiki/Adder100</a>

這題在練習如何用behavioural code描述電路。
```verilog
module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    assign {cout,sum} = a + b + cin;
endmodule
```
---
##### 4-digit BCD adder
Website: <a href="https://hdlbits.01xz.net/wiki/Bcdadd4" target="_blank">https://hdlbits.01xz.net/wiki/Bcdadd4</a>

這題在練習串接BCD adder。
```verilog
module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    wire [3:0] co;
    bcd_fadd bf1(.a(a[3:0]),.b(b[3:0]),.cin(cin),.cout(co[0]),.sum(sum[3:0]));
    bcd_fadd bf2(.a(a[7:4]),.b(b[7:4]),.cin(co[0]),.cout(co[1]),.sum(sum[7:4]));
    bcd_fadd bf3(.a(a[11:8]),.b(b[11:8]),.cin(co[1]),.cout(co[2]),.sum(sum[11:8]));
    bcd_fadd bf4(.a(a[15:12]),.b(b[15:12]),.cin(co[2]),.cout(co[3]),.sum(sum[15:12]));
    assign cout = co[3];
endmodule
```
---
#### Karnaugh Map to Circuit
##### 3-variable
Website: <a href="https://hdlbits.01xz.net/wiki/Kmap1" target="_blank">https://hdlbits.01xz.net/wiki/Kmap1</a>

這題練習如何化簡k-map。
```verilog
module top_module(
    input a,
    input b,
    input c,
    output out  ); 
	assign out = a | b | c;
endmodule
```
---
##### 4-variable(1)
Website: <a href="https://hdlbits.01xz.net/wiki/Kmap2" target="_blank">https://hdlbits.01xz.net/wiki/Kmap2</a>

這題練習如何化簡k-map，值得注意的是，k map畫圈要重疊，才不會發生hazard。
```verilog
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~d) | (~b & ~c) | (a & ~b & d) | (a & c & d) | (b & c & d);
endmodule
```
---
##### 4-variable(2)
Website: <a href="https://hdlbits.01xz.net/wiki/Kmap3" target="_blank">https://hdlbits.01xz.net/wiki/Kmap3</a>

這題練習如何化簡k-map，don't care的部分可以既看成0或看成1化簡，就看方便化簡。
```verilog
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~b & c);
endmodule
```
---
##### 4-variable(3)
Website: <a href="https://hdlbits.01xz.net/wiki/Kmap4" target="_blank">https://hdlbits.01xz.net/wiki/Kmap4</a>

這題練習如何化簡k-map，有點腦筋急轉彎，這題反而不能想用sum of product或product of sum。
```verilog
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
	assign out = a ^ b ^ c ^ d;
endmodule
```
---
##### Minimum SOP and POS
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q2" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q2</a>

這題練習如何畫k map並化簡。
```verilog
module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);
//K map
//cd\ab 00 01 11 10
//	 00  0  0  d  d  
//	 01  0  0  0  0
//	 11  d  1  1  d
//	 10  1  0  0  0
    assign out_sop = (c & d) | (~a & ~b & c);
    assign out_pos = c & (~a | b) & (~b | d);
endmodule
```
---
##### Karnaugh map(1)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q3" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q3</a>

這題練習如何畫k map並化簡。
```verilog
module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule
```
---
##### Karnaugh map(2)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/2012_q1g" target="_blank">https://hdlbits.01xz.net/wiki/Exams/2012_q1g</a>

這題練習如何畫k map並化簡。
```verilog
module top_module (
    input [4:1] x,
    output f
); 
    assign f = (~x[2] & ~x[4])|(~x[1] & x[3])|(x[2] & x[3] & x[4]);
endmodule
```
---
##### K-map implemented with a multiplexer
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q3" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q3</a>

這題練習如何畫k map並化簡，比較有意思的是，這題用到了multiplexer畫k-map。
```verilog
module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    assign mux_in[0] = c | d;
    assign mux_in[1] =  1'b0;
    assign mux_in[2] =    ~d;
    assign mux_in[3] = c & d;
endmodule
```
---
### Sequential Logic
#### Latches and Flip-Flops
##### D flip-flop
Website: <a href="https://hdlbits.01xz.net/wiki/Dff" target="_blank">https://hdlbits.01xz.net/wiki/Dff</a>

這題單純練習如何用sequential block建立DFF，注意要用non-blocking assignment。
```verilog
module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    always@(posedge clk)
        q <= d;
endmodule
```
---
##### D flip-flops
Website: <a href="https://hdlbits.01xz.net/wiki/Dff8" target="_blank">https://hdlbits.01xz.net/wiki/Dff8</a>

這題單純練習如何用sequential block建立8-bit input DFF。
```verilog
module top_module (
    input clk,
    input [7:0] d,
    output reg [7:0] q
);
    always@(posedge clk)
        q <= d;
endmodule
```
---
##### DFF with reset
Website: <a href="https://hdlbits.01xz.net/wiki/Dff8r" target="_blank">https://hdlbits.01xz.net/wiki/Dff8r</a>

這題單純練習如何用sequential block建立8-bit input with DFF synchronous reset。
```verilog
module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output reg [7:0] q
);
    always@(posedge clk)begin
        if(reset) q <= 8'b0000_0000;
        else q <= d;
    end
endmodule
```
---
##### DFF with reset value
Website: <a href="https://hdlbits.01xz.net/wiki/Dff8p" target="_blank">https://hdlbits.01xz.net/wiki/Dff8p</a>

這題練習負緣更新，然後題目所說在reset時要更新成0x34，0x的意思是16進位制。
```verilog
module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output reg [7:0] q
);
    always@(negedge clk)begin
        if(reset) q <= 8'h34;
        else q <= d;
    end
endmodule
```
---
##### DFF with asynchronous reset
Website: <a href="https://hdlbits.01xz.net/wiki/Dff8ar" target="_blank">https://hdlbits.01xz.net/wiki/Dff8ar</a>

這題要做異步復位的DFF。
```verilog
module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output reg [7:0] q
);
    always@(posedge clk, posedge areset)begin
        if(areset) q <= 8'b0000_0000;
        else q <= d;
    end
endmodule
```
---
##### DFF with byte enable
Website: <a href="https://hdlbits.01xz.net/wiki/Dff16e" target="_blank">https://hdlbits.01xz.net/wiki/Dff16e</a>

這題就是DFF加上enable。
```verilog
module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output reg[15:0] q
);
    always@(posedge clk)begin
        if(~resetn) q <= 16'h0000;
        else begin
            q[15:8] <= byteena[1] ? d[15:8]: q[15:8];
            q[7:0] <= byteena[0] ? d[7:0]: q[7:0];
        end
    end
endmodule
```
---
##### D Latch
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4a" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4a</a>

這題練習寫d latch，因為d latch是level-sensitive，所以要用```always@(*)```，而因為是sequential logic，所以要用non-blocking assignment。
```verilog
module top_module (
    input d, 
    input ena,
    output reg q);
    always@(*)begin
        if(ena) q <= d;
    end
endmodule
```
---
##### DFF(1)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4b" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4b</a>

這題練習寫DFF with asynchronous reset。
```verilog
module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output reg q);
    always@(posedge clk,posedge ar)begin
        if(ar) q <= 1'b0;
        else q <= d;
    end
endmodule
```
---
##### DFF(2)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4c" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4c</a>

這題練習寫DFF with synchronous reset，跟上題不同的是，不用考慮reset的正緣觸發。
```verilog
module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output reg q);
    always@(posedge clk)begin
        if(r) q <= 1'b0;
        else q <= d;
    end
endmodule
```
---
##### DFF+gate
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4d" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4d</a>

這題練習寫DFF加上gate的填寫。
```verilog
module top_module (
    input clk,
    input in, 
    output reg out);
    always@(posedge clk)begin
    	out <= out ^ in;
    end
endmodule
```
---
##### Mux and DFF(1)
Website: <a href="https://hdlbits.01xz.net/wiki/Mt2015_muxdff" target="_blank">https://hdlbits.01xz.net/wiki/Mt2015_muxdff</a>

這題練習一個DFF加上一個mux。
```verilog
module top_module (
	input clk,
	input L,
	input r_in,
	input q_in,
	output reg Q);
    always@(posedge clk)begin
    	Q <= L ? r_in : q_in;
    end
endmodule
```
---
##### Mux and DFF(2)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/2014_q4a" target="_blank">https://hdlbits.01xz.net/wiki/Exams/2014_q4a</a>

這題練習一個DFF加上超過1個gate，此時就可以考慮將combinational logic另外在sequential block外assign好。
```verilog
module top_module (
    input clk,
    input w, R, E, L,
    output reg Q
);	
    wire q_in;
    assign q_in = L ? R : (E ? w : Q);
    always@(posedge clk)begin
        Q <= q_in;
    end
endmodule
```
---
##### DFFs and gates
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q4" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q4</a>

這題只是寫3個DFF。
```verilog
module top_module (
    input clk,
    input x,
    output z
); 
    reg q1,q2,q3;
    assign z = ~(q1 | q2 | q3);
    always@(posedge clk)begin
    	q1 <= q1 ^ x;
        q2 <= ~q2 & x;
        q3 <= ~q3 | x;
    end
endmodule
```
---
##### Create circuit from truth table
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q7" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q7</a>

這題練習寫JK-FF。
```verilog
module top_module (
    input clk,
    input j,
    input k,
    output reg Q); 
    always @(posedge clk)begin
        case({j,k})
            2'b00: Q <= Q;
            2'b01: Q <= 1'b0;
            2'b10: Q <= 1'b1;
            2'b11: Q <= ~Q;
        endcase
    end
endmodule
```
---
##### Detect an edge
Website: <a href="https://hdlbits.01xz.net/wiki/Edgedetect" target="_blank">https://hdlbits.01xz.net/wiki/Edgedetect</a>

這題練習寫edge detection，為了比較上個clk的輸入，要多開一個dff存。
```verilog
module top_module (
    input clk,
    input [7:0] in,
    output reg [7:0] pedge
);
    reg [7:0] in_prev;
    always@(posedge clk)begin
        in_prev <= in;
        pedge <= ~in_prev & in;
    end
endmodule
```
---
##### Detect both edges
Website: <a href="https://hdlbits.01xz.net/wiki/Edgedetect2" target="_blank">https://hdlbits.01xz.net/wiki/Edgedetect2</a>

這題練習寫edge detection，跟上題不同的是，要同時判斷0變1和1變0。
```verilog
module top_module (
    input clk,
    input [7:0] in,
    output reg [7:0] anyedge
);
    reg [7:0] in_prev;
    always@(posedge clk)begin
    	in_prev <= in;
        anyedge <= in ^ in_prev;
    end
endmodule
```
---
##### Edge capture register
Website: <a href="https://hdlbits.01xz.net/wiki/Edgecapture" target="_blank">https://hdlbits.01xz.net/wiki/Edgecapture</a>

這題最難的地方就是將edge detection變成edge capture，最簡單的做法就是多or上回合的output。
```verilog
module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output reg [31:0] out
);
    reg [31:0] in_prev;
    always@(posedge clk)begin
        in_prev <= in;
        if(reset)
            out <= 32'h0000_0000;
        else begin
            out <= ~in & in_prev | out;
        end
    end
endmodule
```
---
##### Dual-edge triggered flip-flop
Website: <a href="https://hdlbits.01xz.net/wiki/Dualedge" target="_blank">https://hdlbits.01xz.net/wiki/Dualedge</a>

這題我直接查解答，這個電路設計也太酷。
```verilog
module top_module (
    input clk,
    input d,
    output q
);
    // Why does this work? 
	// After posedge clk, p changes to d^n. Thus q = (p^n) = (d^n^n) = d.
	// After negedge clk, n changes to p^n. Thus q = (p^n) = (p^d^p) = d.
    reg r1, r2;
    assign q = r1 ^ r2;
    always@(posedge clk) r1 <= r2 ^ d;
    always@(negedge clk) r2 <= r1 ^ d;
endmodule
```
---
#### Counters
##### Four-bit binary counter
Website: <a href="https://hdlbits.01xz.net/wiki/Count15" target="_blank">https://hdlbits.01xz.net/wiki/Count15</a>

這題就是用always來計數。
```verilog
module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output reg[3:0] q);
    always@(posedge clk)begin
        if(reset) q <= 4'b0000;
        else q<= q + 4'b0001;
    end
endmodule
```
---
##### Decade counter
Website: <a href="https://hdlbits.01xz.net/wiki/Count10" target="_blank">https://hdlbits.01xz.net/wiki/Count10</a>

這題就是用always來計數，只是數到9，多一個條件。
```verilog
module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output reg[3:0] q);
    always@(posedge clk)begin
        if(reset) q <= 4'b0000;
        else if(q == 4'b1001) q <= 4'b0000;
        else q<= q + 4'b0001;
    end
endmodule
```
---
##### Decade counter again
Website: <a href="https://hdlbits.01xz.net/wiki/Count1to10" target="_blank">https://hdlbits.01xz.net/wiki/Count1to10</a>

這題就是用always來計數，只是變成從1數到10。
```verilog
module top_module (
    input clk,
    input reset,
    output reg[3:0] q);
    always@(posedge clk)begin
        if(reset) q <=4'b0001;
        else if(q == 4'b1010) q<=4'b0001;
        else q <= q + 4'b0001;
    end
endmodule
```
---
##### Slow decade counter
Website: <a href="https://hdlbits.01xz.net/wiki/Countslow" target="_blank">https://hdlbits.01xz.net/wiki/Countslow</a>

這題跟上題差不多，只是變成用另一個輸入計數。
```verilog
module top_module (
    input clk,
    input slowena,
    input reset,
    output reg[3:0] q);
    always@(posedge clk)begin
        if(reset) q <= 4'b0000;
        else if(slowena)begin
            if(q == 4'b1001) q<= 4'b0000;
            else q <= q + 4'b0001;
        end
        else q <= q;
    end
endmodule
```
---
##### Counter 1-12
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q7a" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q7a</a>

這題給了完整的計數器，然後要求外接控制reset和數到12。
```verilog
module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
	assign c_enable = enable;
    assign c_load = reset | (enable & (Q == 4'b1100));
    assign c_d = 4'b0001;
    count4 the_counter (clk, c_enable, c_load, c_d ,Q);
endmodule

```
---
##### Counter 1000
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q7b" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q7b</a>

這題給了BCD counter，然後要連續接3個BCD counter數到1000。
```verilog
module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    wire [3:0] one, ten, hundred;
    wire is_ten, is_hundred;
    assign is_ten = (one == 4'b1001);
    assign is_hundred = is_ten & (ten == 4'b1001);
    assign c_enable = {is_hundred,is_ten,1'b1};
    assign OneHertz = is_hundred & (hundred == 4'b1001);
    bcdcount counter0 (clk, reset, c_enable[0], one);
    bcdcount counter1 (clk, reset, c_enable[1], ten);
    bcdcount counter2 (clk, reset, c_enable[2], hundred);
endmodule
```
---
##### 4-digit decimal counter
Website: <a href="https://hdlbits.01xz.net/wiki/Countbcd" target="_blank">https://hdlbits.01xz.net/wiki/Countbcd</a>

這題要自己刻一個BCD，然後要將4個BCD相接，數到9999。
```verilog
module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    wire is_ten , is_hundred, is_thousand;
    assign is_ten = (q[3:0] == 4'b1001);
    assign is_hundred = (q[7:4] == 4'b1001) & is_ten;
    assign is_thousand = (q[11:8] == 4'b1001) & is_hundred & is_ten;
    assign ena = {is_thousand, is_hundred, is_ten};
    BCD BCD0(.clk(clk),.reset(reset),.enable( 1'b1 ),.q(q[3:0]));
    BCD BCD1(.clk(clk),.reset(reset),.enable(ena[1]),.q(q[7:4]));
    BCD BCD2(.clk(clk),.reset(reset),.enable(ena[2]),.q(q[11:8]));
    BCD BCD3(.clk(clk),.reset(reset),.enable(ena[3]),.q(q[15:12]));
endmodule

module BCD(
	input clk,
    input reset,
    input enable,
    output reg [4:0] q);
    always@(posedge clk)begin
        if(reset) q <= 4'b0000;
        else if(enable)begin
            if(q == 4'b1001) q <= 4'b0000;
            else q <= q + 4'b0001;
        end
        else q <= q;
    end
endmodule
```
---
##### 12-hour clock
Website: <a href="https://hdlbits.01xz.net/wiki/Count_clock" target="_blank">https://hdlbits.01xz.net/wiki/Count_clock</a>

這題刻一個時鐘，算是目前刷題第一次要寫很多程式。
```verilog
module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire enas2,enam1,enam2,enah1,enah2,enapm,ld;
    BCD_zero_to_nine s1( .clk(clk), .reset(reset), .enable(ena), .q(ss[3:0]));
    
    assign enas2 = ena & (ss[3:0] == 4'b1001);
    BCD_zero_to_six s2( .clk(clk), .reset(reset), .enable(enas2), .q(ss[7:4]));
    
    assign enam1 = enas2 & (ss[7:4] == 4'b0101);
    BCD_zero_to_nine m1( .clk(clk), .reset(reset), .enable(enam1), .q(mm[3:0]));
    
    assign enam2 = enam1 & (mm[3:0] == 4'b1001);
    BCD_zero_to_six m2( .clk(clk), .reset(reset), .enable(enam2), .q(mm[7:4]));    
    
    assign enah1 = enam2 & (mm[7:4] == 4'b0101);
    assign ld = enah1 & (hh == 8'b0001_0010);    
    BCD_zero_to_nine_wload h1( .clk(clk), .reset(reset), .enable(enah1), .load(ld), .q(hh[3:0]));
    
    assign enah2 = (enah1 & (hh[3:0] == 4'b1001)) | ld;
    BCD_zero_to_one_wload h2( .clk(clk), .reset(reset), .enable(enah2), .load(ld), .q(hh[7:4]));
    
    assign enapm = enah1 & (hh == 8'b0001_0001);
    PM is_pm( .clk(clk), .reset(reset), .enable(enapm), .pm(pm));
endmodule

module BCD_zero_to_nine(
	input clk,
    input reset,
    input enable,
    output reg [3:0]q);
    always@(posedge clk)begin
        if(reset) q <= 4'b0000;
        else if(enable)begin
            if(q == 4'b1001) q <= 4'b0000;
            else q <= q + 4'b0001;
        end
        else q <= q;
    end
endmodule

module BCD_zero_to_six(
	input clk,
    input reset,
    input enable,
    output reg [3:0]q);
    always@(posedge clk)begin
        if(reset) q <= 4'b0000;
        else if(enable)begin
            if(q == 4'b0101) q <= 4'b0000;
            else q <= q + 4'b0001;
        end
        else q <= q;
    end
endmodule

module BCD_zero_to_nine_wload(
	input clk,
    input reset,
    input enable,
    input load,
    output reg [3:0]q);
    always@(posedge clk)begin
        if(reset) q <= 4'b0010;
        else if(enable)begin
            if(load) q <= 4'b0001;
            else if(q == 4'b1001) q <= 4'b0000;
            else q <= q + 4'b0001;
        end
        else q <= q;
    end
endmodule

module BCD_zero_to_one_wload(
	input clk,
    input reset,
    input enable,
    input load,
    output reg [3:0]q);
    always@(posedge clk)begin
        if(reset) q <= 4'b0001;
        else if(enable)begin
            if(load) q <= 4'b0000;
            else q <= q + 4'b0001;
        end
        else q <= q;
    end
endmodule

module PM(
	input clk,
    input reset,
    input enable,
    output reg pm);
    always@(posedge clk)begin
        if(reset) pm <= 1'b0;
        else if(enable) pm <= pm ^ 1'b1;
        else pm <= pm;
    end
endmodule
```
---
#### Shift Registers
##### 4-bit shift register
Website: <a href="https://hdlbits.01xz.net/wiki/Shift4" target="_blank">https://hdlbits.01xz.net/wiki/Shift4</a>

這題就是寫個shift register，唯一要注意的是load優先級比enable大。
```verilog
module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 
    always@(posedge clk, posedge areset)begin
        if(areset) q <= 4'b0000;
        else if(load) q <= data;
        else if(ena) q <= q >> 1;
        else q <= q;
    end
endmodule
```
---
##### Left/right rotator
Website: <a href="https://hdlbits.01xz.net/wiki/Rotate100" target="_blank">https://hdlbits.01xz.net/wiki/Rotate100</a>

這題就是寫個rotator，可以使用concatenation來實現rotate。
```verilog
module top_module(
    input clk,
    input load,
    input [1:0] ena,
    input [99:0] data,
    output reg [99:0] q); 
    always@(posedge clk)begin
        if(load) q <= data;
        else begin
            case(ena)
                2'b00: q <= q;
                2'b01: q <= { q[0], q[99:1]};
                2'b10: q <= { q[98:0], q[99]};
                2'b11: q <= q;
            endcase
        end
    end
endmodule
```
---
##### Left/right arithmetic shift by 1 or 8
Website: <a href="https://hdlbits.01xz.net/wiki/Shift18" target="_blank">https://hdlbits.01xz.net/wiki/Shift18</a>

這題實作arithmetic shift，需注意的是arithmetic shift往右位移時，高位要用補數補位。
```verilog
module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    always@(posedge clk)begin
        if(load) q <= data;
        else if(ena)begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0],8'b0000_0000};
                2'b10: q <= {q[63],q[63:1]};
                2'b11: q <= {{8{q[63]}},q[63:8]};
            endcase
        end
        else q <= q;
    end
endmodule
```
---
##### 5-bit LFSR
Website: <a href="https://hdlbits.01xz.net/wiki/Lfsr5" target="_blank">https://hdlbits.01xz.net/wiki/Lfsr5</a>

這題實作LFSR。
```verilog
module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 5'h1
    output reg [4:0] q
); 
    always@(posedge clk)begin
        if(reset) q <= 5'b00001;
        else q <= {q[0],q[4],q[3] ^ q[0],q[2:1]};
    end
endmodule
```
---
##### 3-bit LFSR
Website: <a href="https://hdlbits.01xz.net/wiki/Mt2015_lfsr" target="_blank">https://hdlbits.01xz.net/wiki/Mt2015_lfsr</a>

這題跟上題一樣實作LFSR。
```verilog
module top_module (
	input [2:0] SW,      // R
	input [1:0] KEY,     // L and clk
	output [2:0] LEDR);  // Q

    always@(posedge KEY[0])begin
        LEDR <= KEY[1] ? SW: {LEDR[1]^LEDR[2],LEDR[0],LEDR[2]};
    end
endmodule
```
---
##### 32-bit LFSR
Website: <a href="https://hdlbits.01xz.net/wiki/Lfsr32" target="_blank">https://hdlbits.01xz.net/wiki/Lfsr32</a>

這題還是實作LFSR，taps的意思是指在對應的output放上```xor q[0]```，像說taps at 1意思就是``` q[1] ^ q[0]```。
```verilog
module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output reg [31:0] q
); 
    always@(posedge clk)begin
        if(reset) q <= 32'h1;
        else q <= {q[0],q[31:23],q[22]^q[0],q[21:3],q[2]^q[0],q[1]^q[0]};
    end
endmodule
```
---
##### Shift register(1)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/m2014_q4k" target="_blank">https://hdlbits.01xz.net/wiki/Exams/m2014_q4k</a>

這題單純練習pipeline怎麼切，總之就是多開幾個reg。
```verilog
module top_module (
    input clk,
    input resetn,   // synchronous reset
    input in,
    output reg out);
	reg q1, q2, q3;
    always@(posedge clk)begin
        if(~resetn) {q1,q2,q3,out} <= 4'b0000;
        else {q1,q2,q3,out} <= {in,q1,q2,q3};
    end
endmodule
```
---
##### Shift register(2)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/2014_q4b" target="_blank">https://hdlbits.01xz.net/wiki/Exams/2014_q4b</a>

這題單純練習寫一個module，然後接成pipeline。
```verilog
module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    MUXDFF ff0( .E(KEY[1]), .clk(KEY[0]), .L(KEY[2]), .w(LEDR[1]), .R(SW[0]), .q(LEDR[0]));
    MUXDFF ff1( .E(KEY[1]), .clk(KEY[0]), .L(KEY[2]), .w(LEDR[2]), .R(SW[1]), .q(LEDR[1]));
    MUXDFF ff2( .E(KEY[1]), .clk(KEY[0]), .L(KEY[2]), .w(LEDR[3]), .R(SW[2]), .q(LEDR[2]));
    MUXDFF ff3( .E(KEY[1]), .clk(KEY[0]), .L(KEY[2]), .w(KEY[3]), .R(SW[3]), .q(LEDR[3]));
endmodule

module MUXDFF (
    input E,
    input clk,
    input L,
    input w,
    input R,
    output q);
    always@(posedge clk)begin
        case({L,E})
            2'b00: q <= q;
            2'b01: q <= w;
            default: q <= R;
        endcase
    end
endmodule
```
---
##### 3-input LUT
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q12" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q12</a>

這題單純練習寫一個shift register和multiplexer。
```verilog
module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output reg Z ); 
    reg [7:0] Q;
    always@(posedge clk)begin
        if(enable) Q <= {Q[6:0],S};
        else Q <= Q;
    end
    assign Z = Q[{A,B,C}];
endmodule
```
---
#### More Circuits
##### Rule 90
Website: <a href="https://hdlbits.01xz.net/wiki/Rule90" target="_blank">https://hdlbits.01xz.net/wiki/Rule90</a>

這題單純練習concatenation的使用。
```verilog
module top_module(
    input clk,
    input load,
    input [511:0] data,
    output reg [511:0] q ); 
    always @(posedge clk)begin
        if(load) q <= data;
        else q <= {1'b0,q[511:1]} ^ {q[510:0],1'b0};
    end
endmodule
```
---
##### Rule 110
Website: <a href="https://hdlbits.01xz.net/wiki/Rule110" target="_blank">https://hdlbits.01xz.net/wiki/Rule110</a>

這題單純練習concatenation的使用，跟上題不同的是，這題有點卡諾圖化簡的感覺。
```verilog
module top_module(
    input clk,
    input load,
    input [511:0] data,
    output reg [511:0] q
); 
    always@(posedge clk)begin
        if(load) q <= data;
        else q <= (q ^ {q[510:0],1'b0}) | (~{1'b0,q[511:1]} & q);
    end
endmodule
```
---
##### Conway's Game of Life 16x16
Website: <a href="https://hdlbits.01xz.net/wiki/Conwaylife" target="_blank">https://hdlbits.01xz.net/wiki/Conwaylife</a>

這題練習使用for迴圈，還有debug的耐心。
```verilog
module top_module(
    input clk,
    input load,
    input [255:0] data,
    output reg [255:0] q );
    reg [255:0] next_q;
    reg [323:0] q_padding;
    reg [3:0] answer[255:0];
    integer i,j;
    
    always@(*)begin
    	//update q_padding
        q_padding[17:0] = {q[240],q[255:240],q[255]};
        q_padding[323:306] = {q[0],q[15:0],q[15]};
        for(i = 1; i < 17 ; i++)begin
            q_padding[i*18 +: 18] = {q[(i-1)*16],q[(i-1)*16 +: 16],q[i*16-1]};
        end
        //calculate
        for(i=0; i<16; i++)begin
            for(j=0; j<16; j++)begin
                //center is q_padding[18*(i+1)+(j+1)]
                answer[16*i + j] = q_padding[18*i+(j  )] +
                		 q_padding[18*i+(j+1)] +
                		 q_padding[18*i+(j+2)] +
                		 q_padding[18*(i+1)+(j  )] +
                		 q_padding[18*(i+1)+(j+2)] +
                		 q_padding[18*(i+2)+(j  )] +
                		 q_padding[18*(i+2)+(j+1)] +
                		 q_padding[18*(i+2)+(j+2)];                
                case(answer[16*i + j])
                    4'b0011: next_q[16*i+j] = 1'b1;
                    4'b0010: next_q[16*i+j] = q[16*i+j];
                    default: next_q[16*i+j] = 1'b0;
                endcase
            end
        end
    end
    
    always@(posedge clk)begin
        if(load) q <= data;
        else q <= next_q;
    end
endmodule
```
---
#### Finite State Machines
##### Simple FSM 1 (asynchronous reset)
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm1" target="_blank">https://hdlbits.01xz.net/wiki/Fsm1</a>

這題寫個FSM，可以進一步化簡。
```verilog
module top_module(
    input clk,
    input areset,    // Asynchronous reset to state B
    input in,
    output out);//  

    parameter A=0, B=1; 
    reg state;

    always @(posedge clk, posedge areset) begin    // This is a sequential always block
        // State flip-flops with asynchronous reset
        if(areset) state <=  B;
        else begin
            state <= ~(state ^ in);
        end
    end
	
    // Output logic
    assign out = state;
endmodule
```
---
##### Simple FSM 1 (synchronous reset)
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm1s" target="_blank">https://hdlbits.01xz.net/wiki/Fsm1s</a>

這題寫個FSM，跟上一題只差在Synchronous reset，這題練習正常寫FSM。
```verilog
// Note the Verilog-1995 module declaration syntax here:
module top_module(clk, reset, in, out);
    input clk;
    input reset;    // Synchronous reset to state B
    input in;
    output out;

    // Fill in state name declarations

    reg present_state, next_state;

    always@(*)begin
        case(present_state)
        	1'b0: next_state = in? 1'b0: 1'b1;
            1'b1: next_state = in? 1'b1: 1'b0;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)present_state <= 1'b1;
        else present_state <= next_state;
    end
    assign out = present_state;
endmodule
```
---
##### Simple FSM 2 (asynchronous reset)
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm2" target="_blank">https://hdlbits.01xz.net/wiki/Fsm2</a>

這題寫個FSM，跟上上一題只差在邏輯有點差異。
```verilog
module top_module(
    input clk,
    input areset,    // Asynchronous reset to OFF
    input j,
    input k,
    output out); //  

    reg state, next_state;

    always @(*) begin
        // State transition logic
        case(state)
            1'b1: next_state = k? 1'b0: 1'b1;
            1'b0: next_state = j? 1'b1: 1'b0;
        endcase
    end

    always @(posedge clk, posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset) state <= 1'b0;
        else state <= next_state;
    end

    // Output logic
    assign out = state;
endmodule
```
---
##### Simple FSM 2 (synchronous reset)
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm2s" target="_blank">https://hdlbits.01xz.net/wiki/Fsm2s</a>

這題寫個FSM，跟上一題只差在Synchronous reset，這題練習正常寫FSM。
```verilog
module top_module(
    input clk,
    input reset,    // Synchronous reset to OFF
    input j,
    input k,
    output out); //  

    reg state, next_state;

    always @(*) begin
        // State transition logic
        case(state)
            1'b1: next_state = k? 1'b0: 1'b1;
            1'b0: next_state = j? 1'b1: 1'b0;
        endcase
    end

    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if(reset) state <= 1'b0;
        else state <= next_state;
    end

    // Output logic
    assign out = state;
endmodule
```
---
##### Simple state transitions 3
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm3comb" target="_blank">https://hdlbits.01xz.net/wiki/Fsm3comb</a>

這題寫個FSM，只是不需要處理clock。
```verilog
module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    //parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always@(*)begin
        case(state)
            2'b00: next_state = in? 2'b01: 2'b00;
            2'b01: next_state = in? 2'b01: 2'b10;
            2'b10: next_state = in? 2'b11: 2'b00;
            2'b11: next_state = in? 2'b01: 2'b10;
        endcase
    end
    
    // Output logic:  out = f(state) for a Moore state machine
	assign out = &state;
endmodule
```
---
##### Simple one-hot state transitions 3
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm3onehot" target="_blank">https://hdlbits.01xz.net/wiki/Fsm3onehot</a>

這題state是one-hot vector，要求transition table用assign寫，滿特別的。
```verilog
module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = ~in & (state[0] | state[2]);
    assign next_state[B] = in & (state[0] | state[1] | state[3]);
    assign next_state[C] = ~in & (state[1] | state[3]);
    assign next_state[D] = in & (state[2]);

    // Output logic: 
    assign out = state[3];

endmodule
```
---
##### Simple FSM 3 (asynchronous reset)
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm3" target="_blank">https://hdlbits.01xz.net/wiki/Fsm3</a>

這題寫FSM，照著寫就結束了。
```verilog
module top_module(
    input clk,
    input in,
    input areset,
    output out); //

    // State transition logic
    reg [1:0] state, next_state;
    always@(*)begin
        case(state)
            2'b00: next_state = in? 2'b01: 2'b00;
            2'b01: next_state = in? 2'b01: 2'b10;
            2'b10: next_state = in? 2'b11: 2'b00;
            2'b11: next_state = in? 2'b01: 2'b10;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk, posedge areset)begin
        if(areset) state <= 2'b00;
        else state <= next_state;
    end
    // Output logic
	assign out = &state;
endmodule
```
---
##### Simple FSM 3 (synchronous reset)
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm3s" target="_blank">https://hdlbits.01xz.net/wiki/Fsm3s</a>

這題寫FSM，照著寫就結束了，跟上題相比，就是把改成synchronous reset。
```verilog
module top_module(
    input clk,
    input in,
    input reset,
    output out); //

    // State transition logic
    reg [1:0] state, next_state;
    always@(*)begin
        case(state)
            2'b00: next_state = in? 2'b01: 2'b00;
            2'b01: next_state = in? 2'b01: 2'b10;
            2'b10: next_state = in? 2'b11: 2'b00;
            2'b11: next_state = in? 2'b01: 2'b10;
        endcase
    end
    // State flip-flops with synchronous reset
    always@(posedge clk)begin
        if(reset) state <= 2'b00;
        else state <= next_state;
    end
    // Output logic
	assign out = &state;
endmodule
```
---
##### Design a Moore FSM
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q4" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q4</a>

這題考閱讀，照著題意接FSM。
```verilog
module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 
    reg [1:0]state, next_state;
    assign next_state = {s[2],~(s[3]^s[2])&s[1]};

    always@(posedge clk)begin
        if(reset) state <= 2'b00;
        else state <= next_state;
    end
    
	always@(*)begin
        case(state)
            2'b00: {fr3,fr2,fr1} = 3'b111;
            2'b01: {fr3,fr2,fr1} = 3'b011;
            2'b10: {fr3,fr2,fr1} = 3'b001;
            2'b11: {fr3,fr2,fr1} = 3'b000;
        endcase
    end
    
    always@(posedge clk)begin
        if(reset) dfr <= 1'b1;
        else begin
        	if(state > next_state) dfr <= 1'b1;
        	else if(state== next_state) dfr <= dfr;
        	else dfr <= 1'b0;
        end
    end
endmodule
```
---
##### Lemmings 1
Website: <a href="https://hdlbits.01xz.net/wiki/Lemmings1" target="_blank">https://hdlbits.01xz.net/wiki/Lemmings1</a>

這題透過FSM實作遊戲的原理。
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    output walk_left,
    output walk_right); //  

    // parameter LEFT=1, RIGHT=0, ...
    reg state, next_state;

    always @(*) begin
        // State transition logic
        case(state)
        	1'b0: next_state = bump_right? 1'b1: 1'b0;
            1'b1: next_state = bump_left?  1'b0: 1'b1;
        endcase
    end

    always @(posedge clk, posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset) state <= 1'b1;
        else state <= next_state;
    end

    // Output logic
	assign walk_left = state;
    assign walk_right = ~state;
endmodule
```
---
##### Lemmings 2
Website: <a href="https://hdlbits.01xz.net/wiki/Lemmings2" target="_blank">https://hdlbits.01xz.net/wiki/Lemmings2</a>

這題是上題的延伸，主要是bump的條件要多寫。
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    output walk_left,
    output walk_right,
    output aaah ); 
    //0 right_fall, 1 left_fall, 2 right, 3 left
    reg [1:0]state,next_state;
    
    always@(*)begin
        if(~ground) next_state = {1'b0,state[0]};
        else begin
            case(state)
                2'b00: next_state = 2'b10;
                2'b01: next_state = 2'b11;
            	2'b10: next_state = bump_right? 2'b11: 2'b10;
            	2'b11: next_state = bump_left ? 2'b10: 2'b11;
        	endcase
        end
    end
    
    always@(posedge clk,posedge areset)begin
        if(areset) state <= 2'b11;
        else state <= next_state;
    end
    
    assign walk_left = &state;
    assign walk_right = state[1] & ~state[0];
    assign aaah = ~state[1];
endmodule
```
---
##### Lemmings 3
Website: <a href="https://hdlbits.01xz.net/wiki/Lemmings3" target="_blank">https://hdlbits.01xz.net/wiki/Lemmings3</a>

這題是上題的延伸，主要是dig的條件要多寫，然後如果照著fsm格式寫應該會快樂不少。
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    input dig,
    output walk_left,
    output walk_right,
    output aaah,
    output digging ); 
    //right 3'b000, left 3'b001, bump right 3'b010, bump left 3'b011, dig right 3'b100, dig left 3'b101
    reg [2:0] state,next_state;
    
    always@(*)begin
        case(state)
            3'b000: next_state= ground? (dig? 3'b100: (bump_right? 3'b001:3'b000)): 3'b010;
            3'b001: next_state= ground? (dig? 3'b101: (bump_left ? 3'b000:3'b001)): 3'b011;
            3'b010: next_state= ground? 3'b000: 3'b010;
            3'b011: next_state= ground? 3'b001: 3'b011;
            3'b100: next_state= ground? 3'b100: 3'b010;
            3'b101: next_state= ground? 3'b101: 3'b011;
            default: next_state= 3'bxxx;
        endcase
    end
    
    always@(posedge clk,posedge areset)begin
        if(areset) state <= 3'b001;
        else state <= next_state;
    end
    
    assign walk_left = ~state[2] & ~state[1] & state[0];
    assign walk_right = &(~state);
    assign aaah = ~state[2] & state[1];
    assign digging = state[2];
endmodule
```
---
##### Lemmings 4
Website: <a href="https://hdlbits.01xz.net/wiki/Lemmings4" target="_blank">https://hdlbits.01xz.net/wiki/Lemmings4</a>

這題是上題的延伸，也是FSM和counter的結合，這裡只需要注意counter在sequential的logic不要寫錯了，我當時把```if(~next_state[2] & next_state[1])```寫成```if(~state[2] & state[1])```，一直少算一回合。
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    input dig,
    output walk_left,
    output walk_right,
    output aaah,
    output digging ); 
    //right 3'b000, left 3'b001, bump right 3'b010, bump left 3'b011, dig right 3'b100, dig left 3'b101,splatter 3'b110
    reg [2:0] state,next_state;
    reg [7:0] count;
    
    always@(*)begin
        case(state)
            3'b000: next_state= ground? (dig? 3'b100: (bump_right? 3'b001:3'b000)): 3'b010;
            3'b001: next_state= ground? (dig? 3'b101: (bump_left ? 3'b000:3'b001)): 3'b011;
            3'b010: next_state= ground? ((count>8'd20)? 3'b110: 3'b000): 3'b010;
            3'b011: next_state= ground? ((count>8'd20)? 3'b110: 3'b001): 3'b011;
            3'b100: next_state= ground? 3'b100: 3'b010;
            3'b101: next_state= ground? 3'b101: 3'b011;
            3'b110: next_state = 3'b110;
            default: next_state= 3'bxxx;
        endcase
    end
    
    always@(posedge clk,posedge areset)begin
        if(areset)begin
            state <= 3'b001;
            count <= 8'd0;
        end
        else begin
            state <= next_state;
            if(~next_state[2] & next_state[1])
                count <= count + 8'd1;
            else
                count <= 8'd0;
        end
    end
    
    assign walk_left = ~state[2] & ~state[1] & state[0];
    assign walk_right = &(~state);
    assign aaah = ~state[2] & state[1];
    assign digging = state[2] & ~state[1];
endmodule
```
---
##### One-hot FSM
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm_onehot" target="_blank">https://hdlbits.01xz.net/wiki/Fsm_onehot</a>

這題不用寫DFF，而且又是one hot vector，所以很適合用assign來寫完transition logic。
```verilog
module top_module(
    input in,
    input [9:0] state,
    output [9:0] next_state,
    output out1,
    output out2);
    //next state
    assign next_state[0] = ~in & (state[0]| state[1]|  state[2]| state[3]|  state[4]| state[7]| state[8]| state[9]);
    assign next_state[1] = in & (state[0]| state[8]| state[9]);
    assign next_state[2] = in & state[1];
    assign next_state[3] = in & state[2];
    assign next_state[4] = in & state[3];
    assign next_state[5] = in & state[4];
    assign next_state[6] = in & state[5];
    assign next_state[7] = in & (state[6]| state[7]);
    assign next_state[8] = ~in & state[5];
    assign next_state[9] = ~in & state[6];
    //out
    assign out1 = state[8]| state[9];
    assign out2 = state[7]| state[9];
endmodule
```
---
##### PS/2 packet parser
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm_ps2" target="_blank">https://hdlbits.01xz.net/wiki/Fsm_ps2</a>

這題有點edge detection的感覺，或許可以開3個reg存前3回合的輸入，不過用FSM可以更理想的省空間。
```verilog
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //
    //2'b00 -> reset
    //2'b01 -> get the 1xx
    //2'b11 -> output done = 1
    reg [1:0]state, next_state;
    // State transition logic (combinational)
    always@(*)begin
        case(state)
            2'b00: next_state = in[3]? 2'b01: 2'b00;
            2'b01: next_state = 2'b10;
            2'b10: next_state = 2'b11;
            2'b11: next_state = in[3]? 2'b01: 2'b00;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk)begin
        if(reset) state <= 2'b00;//reset
        else state <= next_state;
    end
    // Output logic
    assign done = state[1] & state [0];//done when state== 2'b11
endmodule
```
---
##### PS/2 packet parser and datapath
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm_ps2data" target="_blank">https://hdlbits.01xz.net/wiki/Fsm_ps2data</a>

這題延續上題，就只是開個datapath來存過往資料。
```verilog
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    //2'b00 -> reset
    //2'b01 -> get the 1xx
    //2'b11 -> output done = 1
    reg [1:0]state, next_state;
    // State transition logic (combinational)
    always@(*)begin
        case(state)
            2'b00: next_state = in[3]? 2'b01: 2'b00;
            2'b01: next_state = 2'b10;
            2'b10: next_state = 2'b11;
            2'b11: next_state = in[3]? 2'b01: 2'b00;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk)begin
        if(reset) state <= 2'b00;//reset
        else state <= next_state;
    end
    // Output logic
    assign done = state[1] & state [0];//done when state== 2'b11
    
    // New: Datapath to store incoming bytes.
    reg [7:0] in1, in2, in3;
    always@(posedge clk)begin
        in1 <= in;
        in2 <= in1;
        in3 <= in2;
    end
    
    assign out_bytes = done? {in3, in2, in1}: {24{1'b0}};
    
endmodule
```
---
##### Serial receiver
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm_serial" target="_blank">https://hdlbits.01xz.net/wiki/Fsm_serial</a>

這題單純考怎麼將應用題轉成FSM。
```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    //data*8 + start + stop + idle + ??? = 12state
    reg[3:0] state, next_state;
    always@(*)begin
        case(state)
            4'd0: next_state = in? 4'd0: 4'd1;//idle
            4'd1: next_state = 4'd2;//start
            4'd2: next_state = 4'd3;//data1
            4'd3: next_state = 4'd4;//data2
            4'd4: next_state = 4'd5;//data3
            4'd5: next_state = 4'd6;//data4
            4'd6: next_state = 4'd7;//data5
            4'd7: next_state = 4'd8;//data6
            4'd8: next_state = 4'd9;//data7
            4'd9: next_state = in? 4'd10: 4'd11;//data8
            4'd10: next_state = in? 4'd0: 4'd1;//stop
            4'd11: next_state = in? 4'd0: 4'd11;//???
            default: next_state = 4'bxxxx;
        endcase
    end
    
    assign done = (state == 4'd10);
    
    always@(posedge clk)begin
        if(reset) state <= 4'b0000;
        else state <= next_state;
    end
endmodule
```
---
##### Serial receiver and datapath
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm_serialdata" target="_blank">https://hdlbits.01xz.net/wiki/Fsm_serialdata</a>

這題接續上題，多加一個datapath存資料。
```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    //data*8 + start + stop + idle + ??? = 12state
    reg[3:0] state, next_state;
    always@(*)begin
        case(state)
            4'd0: next_state = in? 4'd0: 4'd1;//idle
            4'd1: next_state = 4'd2;//start
            4'd2: next_state = 4'd3;//data1
            4'd3: next_state = 4'd4;//data2
            4'd4: next_state = 4'd5;//data3
            4'd5: next_state = 4'd6;//data4
            4'd6: next_state = 4'd7;//data5
            4'd7: next_state = 4'd8;//data6
            4'd8: next_state = 4'd9;//data7
            4'd9: next_state = in? 4'd10: 4'd11;//data8
            4'd10: next_state = in? 4'd0: 4'd1;//stop
            4'd11: next_state = in? 4'd0: 4'd11;//???
            default: next_state = 4'bxxxx;
        endcase
    end
    
    assign done = (state == 4'd10);
    
    always@(posedge clk)begin
        if(reset) state <= 4'b0000;
        else state <= next_state;
    end
    // New: Datapath to latch input bits.
    reg [8:0] data;
    always@(posedge clk)begin
        data <= {in,data[8:1]};
    end
    assign out_byte = data[7:0];
endmodule
```
---
##### Serial receiver with parity checking
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm_serialdp" target="_blank">https://hdlbits.01xz.net/wiki/Fsm_serialdp</a>

這題接續上題，data input從8 bit變9 bit，所以FSM要改。然後有個細節要注意，就是parity的reset等到start階段時也要reset。至於說如何判別```is_start```，這裡得用```assign is_start = (next_state == 4'd1);```，不能用```assign is_start = (state == 4'd1);```的原因在於，會晚一個cycle。所以把握一個原則，sequential logic中若用到狀態，記得要寫next_state。
```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Modify FSM and datapath from Fsm_serialdata
    // Use FSM from Fsm_serial
    //data*8 + start + stop + idle + ??? = 12state
    reg[3:0] state, next_state;
    always@(*)begin
        case(state)
            4'd0: next_state = in? 4'd0: 4'd1;//idle
            4'd1: next_state = 4'd2;//start
            4'd2: next_state = 4'd3;//data1
            4'd3: next_state = 4'd4;//data2
            4'd4: next_state = 4'd5;//data3
            4'd5: next_state = 4'd6;//data4
            4'd6: next_state = 4'd7;//data5
            4'd7: next_state = 4'd8;//data6
            4'd8: next_state = 4'd9;//data7
            4'd9: next_state = 4'd10;//data8
            4'd10: next_state = in? 4'd11: 4'd12;//data9
            4'd11: next_state = in? 4'd0: 4'd1;//stop
            4'd12: next_state = in? 4'd0: 4'd12;//???
            default: next_state = 4'bxxxx;
        endcase
    end
    
    always@(posedge clk)begin
        if(reset) state <= 4'b0000;
        else begin
        state <= next_state;
        valid <= odd;
        end
    end
    // New: Datapath to latch input bits.
    reg [9:0] data;
    always@(posedge clk)begin
        data <= {in,data[9:1]};
    end
    
    // New: Add parity checking.
    wire odd,is_start;
    assign is_start = (next_state == 4'd1);
    parity pr(.clk(clk),.reset(reset|is_start),.in(in),.odd(odd));
    reg valid;
    
    assign out_byte = valid? data[7:0]: 8'd0;
    assign done = (state == 4'd11) & valid;
endmodule
```
---
##### Sequence recognition
Website: <a href="https://hdlbits.01xz.net/wiki/Fsm_hdlc" target="_blank">https://hdlbits.01xz.net/wiki/Fsm_hdlc</a>

這題分別對連續5，6，7以上個1做判斷，並做相對應的輸出，其實很像進階版的edge detection，不過可以用FSM實現，可以少幾個register。
```verilog
module top_module(
    input clk,
    input reset,    // Synchronous reset
    input in,
    output disc,
    output flag,
    output err);
    reg [3:0] state, next_state;
    parameter none = 4'd0;
    parameter one = 4'd1;
    parameter two = 4'd2;
    parameter three = 4'd3;
    parameter four = 4'd4;
    parameter five = 4'd5;
    parameter six = 4'd6;
    parameter seven = 4'd7;
    parameter discard = 4'd8;
    parameter fg = 4'd9;
    
    always@(*)begin
        case(state)
            none: next_state = in? one: none;
            one: next_state = in? two: none;
            two: next_state = in? three: none;
            three: next_state = in? four: none;
            four: next_state = in? five: none;
            five: next_state = in? six: discard;
            six: next_state = in? seven: fg;
            seven: next_state = in? seven: none;
            discard: next_state = in? one: none;
            fg: next_state = in? one: none;
            default: next_state = 4'bxxxx;
        endcase
    end
    
    always@(posedge clk)begin
        if(reset) state <= none;
        else state <= next_state;
    end
    
    assign disc = (state == discard);
    assign flag = (state == fg);
    assign err = (state == seven);
endmodule
```
---
##### Q8: Design a Mealy FSM
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q8" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2013_q8</a>

這題應該是這網站上第一題明確指出需使用mealy machine的題目。
```verilog
module top_module (
    input clk,
    input aresetn,    // Asynchronous active-low reset
    input x,
    output z ); 
    reg [1:0] state, next_state;
    parameter zero_bit = 2'b00;
    parameter one_bit = 2'b01;
    parameter two_bit = 2'b10;
    
    always@(*)begin
        case(state)
        	zero_bit: next_state = x? one_bit: zero_bit;
            one_bit: next_state = x? one_bit: two_bit;
            two_bit: next_state = x? one_bit: zero_bit;
            default: next_state = 4'bxxxx;
        endcase
    end
    
    always@(posedge clk, negedge aresetn)begin
        if(~aresetn) state <= zero_bit;
        else state <= next_state;
    end
    
    assign z = (state == two_bit) && x;
endmodule
```
---
##### Q5a: Serial two's complementer (Moore FSM)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q5a" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q5a</a>

這題用moore machine寫2補數，就只有lsb的1輸出改1，沒什麼太難的。
```verilog
module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    reg [1:0] state, next_state;
    parameter idle = 2'b00;
    parameter zero = 2'b01;
    parameter one = 2'b10;
    
    always@(*)begin
        case(state)
            idle: next_state = x? zero: idle;
            zero: next_state = x? one: zero;
            one: next_state = x? one: zero;
            default: next_state = 2'bxx;
        endcase
    end
    
    always@(posedge clk, posedge areset)begin
        if(areset) state <= 2'b00;
        else state <= next_state;
    end
    
    assign z = (state == zero);
endmodule
```
---
##### Q5b: Serial two's complementer (Mealy FSM)
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q5b" target="_blank">https://hdlbits.01xz.net/wiki/Exams/ece241_2014_q5b</a>

這題用mealy machine，因為mealy machine比moore machine少一個state，所以輸出早一個週期。
```verilog
module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    reg state, next_state;
    parameter idle = 1'b0;
    parameter comp = 1'b1;
    
    assign next_state = state | x;
    
    always@(posedge clk,posedge areset)begin
        if(areset) state = idle;
        else state = next_state;
    end
    
    assign z = (state & ~x) | (~state & x);
endmodule
```
---
##### Q3a: FSM
Website: <a href="https://hdlbits.01xz.net/wiki/Exams/2014_q3fsm" target="_blank">https://hdlbits.01xz.net/wiki/Exams/2014_q3fsm</a>

這題在考怎麼算三個cycle內有兩個1，其實可以開個datapath，然後取xnor和or。然後有個細節要注意，就是當reset和A轉換為B時要將datapath更新成3'b000，這裡得寫```else if(state == A) temp <= 3'b000;```而不是寫```else if(next_state == B) temp <= 3'b000;```的原因在於，```next_state == B```也可能代表```next_state == D```。
```verilog
module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);	
    reg [1:0] state, next_state;
    parameter A = 2'b00;
    parameter B = 2'b01;
    parameter C = 2'b10;
    parameter D = 2'b11;
    
    always@(*)begin
        case(state)
            A: next_state = s? B: A;
            B: next_state = C;
            C: next_state = D;
            D: next_state = B;
        endcase
    end
    
    reg [2:0]temp;
    always@(posedge clk)begin 
        if(reset) state <= A;
        else state <= next_state;
    end
    
    always@(posedge clk)begin 
        if(reset) temp <= 3'b000;
        else if(state == A) temp <= 3'b000;
        else temp <= {temp[1:0],w};
    end
    
    assign z = (state == B) && ~(^temp) && (|temp);
endmodule
```