---
title: HDLBits tutorial
author: Three Month
date: 2023-06-15
category: Jekyll
layout: post
---

## Getting Started
### Getting Started
Website: <a href="https://hdlbits.01xz.net/wiki/Step_one" target="_blank">https://hdlbits.01xz.net/wiki/Step_one</a>

這題是教你怎麼操作平台的，然後要對one輸出1。這裡有個細節是給值時盡量寫的清楚一點，像這裡1bit，就可以不是只給1，而是給1'b1。
```verilog
module top_module( output one );
    assign one = 1'b1;
endmodule
```
---
### Output Zero
Website: <a href="https://hdlbits.01xz.net/wiki/Zero" target="_blank">https://hdlbits.01xz.net/wiki/Zero</a>

這題跟上題大同小異，只是換成輸出0。
```verilog
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 1'b0;
endmodule
```
---
## Verilog Language
### Basics
#### Simple wire
Website: <a href="https://hdlbits.01xz.net/wiki/Wire" target="_blank">https://hdlbits.01xz.net/wiki/Wire</a>

這題就是簡單的把out和in接在一起。
```verilog
module top_module( input in, output out );
	assign out = in;
endmodule
```
---
#### Four wires
Website: <a href="https://hdlbits.01xz.net/wiki/Wire4" target="_blank">https://hdlbits.01xz.net/wiki/Wire4</a>

這題就照著圖接線，w和a相接，xy和b相接，z和c相接。
```verilog
module top_module( 
    input a,b,c,
    output w,x,y,z );
	assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule
```
---
#### Inverter
Website: <a href="https://hdlbits.01xz.net/wiki/Notgate" target="_blank">https://hdlbits.01xz.net/wiki/Notgate</a>

這題要寫一個not gate。  
值得注意的是，verilog中有分bitwise operator和logical operator，bitwise operator就是對input的每個bit都做相對的運算，所以最後輸出的bit數會跟input一樣。而logical operator只會邏輯上做運算，最後只會輸出1 bit。   
所以說bitwise not符號是```~```，而logical not符號是```!```，雖然這題input只有1 bit沒差，不過細節可能要注意。
```verilog
module top_module( input in, output out );
	assign out = ~in;
endmodule
```
---
#### AND gate
Website: <a href="https://hdlbits.01xz.net/wiki/Andgate" target="_blank">https://hdlbits.01xz.net/wiki/Andgate</a>

這題就刻一個and gate，跟上題差不多，要注意的是bitwise and符號是```&```，而logical and符號是```&&```，
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
	assign out = a & b;
endmodule
```
---
#### NOR gate
Website: <a href="https://hdlbits.01xz.net/wiki/Norgate" target="_blank">https://hdlbits.01xz.net/wiki/Norgate</a>

這題就刻一個nor gate，跟上題差不多，要注意的是bitwise or符號是```~```，而logical and符號是```~~```，
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule
```
---
#### XNOR gate
Website: <a href="https://hdlbits.01xz.net/wiki/Xnorgate" target="_blank">https://hdlbits.01xz.net/wiki/Xnorgate</a>

這題就刻一個xnor gate，跟上題差不多，要注意的是bitwise xor符號是```^```，而verilog中沒有logical xor運算。
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule
```
---
#### Declaring wires
Website: <a href="https://hdlbits.01xz.net/wiki/Wire_decl" target="_blank">https://hdlbits.01xz.net/wiki/Wire_decl</a>

這題引入了wire的概念，wire就是在線路複雜時，提供節點來幫助閱讀。補充一下，input和output本身就是wire。
```verilog
`default_nettype none
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out,
    output out_n   ); 
	wire a_and_b, c_and_d;
    assign a_and_b = a & b;
    assign c_and_d = c & d;
    assign out = a_and_b | c_and_d;
    assign out_n = ~out;
endmodule
```
---
#### 7458 chip
Website: <a href="https://hdlbits.01xz.net/wiki/7458" target="_blank">https://hdlbits.01xz.net/wiki/7458</a>

這題跟上題類似，就是線路稍微複雜，可以直接寫，也可以使用wire幫助閱讀。
```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);
    assign p2y = (p2a & p2b) | (p2c & p2d);
endmodule
```
---
### Vectors
#### Vectors
Website: <a href="https://hdlbits.01xz.net/wiki/Vector0" target="_blank">https://hdlbits.01xz.net/wiki/Vector0</a>

這題是將[2:0] vec分別賦值給[2:0] outv和{o2,o1,o0}，補充說明，```assign {o2,o1,o0} = vec;```等價於```assign o2 = vec[2]; assign o1 = vec[1]; assign o0 = vec[0];```。

```verilog
module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign outv = vec;
    assign {o2,o1,o0} = vec;
endmodule
```
---
#### Vectors in more detail
Website: <a href="https://hdlbits.01xz.net/wiki/Vector1" target="_blank">https://hdlbits.01xz.net/wiki/Vector1</a>

跟上題大同小異，```assign {out_hi,out_lo} = in;```等價於```assign out_hi = in[15:8]; assign out_lo = in[7:0];```。
```verilog
`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign {out_hi,out_lo} = in;
endmodule
```
---
#### Vector part select
Website: <a href="https://hdlbits.01xz.net/wiki/Vector2" target="_blank">https://hdlbits.01xz.net/wiki/Vector2</a>

跟上題大同小異，```assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};```等價於```	assign out[31:24] = in[ 7: 0]; assign out[23:16] = in[15: 8]; assign out[15: 8] = in[23:16]; assign out[ 7: 0] = in[31:24];```。
```verilog
module top_module( 
    input [31:0] in,
    output [31:0] out );
    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};
endmodule
```
---
#### Bitwise operators
Website: <a href="https://hdlbits.01xz.net/wiki/Vectorgates" target="_blank">https://hdlbits.01xz.net/wiki/Vectorgates</a>

這題主要講述bitwise operators和logical operators的差異。像說bitwise or的符號為```|```，logical or的符號為```||```，bitwise not的符號為```~```，logical not的符號為```!```。這題的not是bitwise not，不要弄混了。
```verilog
module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
	assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not = ~ {b,a};
endmodule
```
---
#### Four-input gates
Website: <a href="https://hdlbits.01xz.net/wiki/Gates4" target="_blank">https://hdlbits.01xz.net/wiki/Gates4</a>

這題在複習各種gate的用法。
```verilog
module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = in[3] & in[2] & in[1] & in[0];
    assign out_or = in[3] | in[2] | in[1] | in[0];
    assign out_xor = in[3] ^ in[2] ^ in[1] ^ in[0];
endmodule
```

#### Vector concatenation operator
Website: <a href="https://hdlbits.01xz.net/wiki/Vector3" target="_blank">https://hdlbits.01xz.net/wiki/Vector3</a>

這題在教concatenation的概念，然後因為題目要求要padding11在最右邊2bits，所以要加上2'b11。
```verilog
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z} = {a,b,c,d,e,f,2'b11};

endmodule
```
---
#### Vector reversal 1
Website: <a href="https://hdlbits.01xz.net/wiki/Vectorr" target="_blank">https://hdlbits.01xz.net/wiki/Vectorr</a>

這題當然能用concatenation的概念完成，當然如果想寫個類似for loop的方法連線，可以參考generate語法。
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
	generate
		genvar i;
		for (i=0; i<8; i = i+1) begin: my_block_name
			assign out[i] = in[8-i-1];
		end
	endgenerate
endmodule
```
---
#### Replication operator
Website: <a href="https://hdlbits.01xz.net/wiki/Vector4" target="_blank">https://hdlbits.01xz.net/wiki/Vector4</a>

這題將8bit轉成32bit，並且多餘的24bit要填入in[7]，所以語法如下。
```verilog
module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = { { 24{ in[7] } },in};

endmodule
```
---
#### More replication
Website: <a href="https://hdlbits.01xz.net/wiki/Vector5" target="_blank">https://hdlbits.01xz.net/wiki/Vector5</a>

這題也是練習replication，aaaaabbbbbcccccdddddeeeee可以寫成```{ {5{a}},{5{b}},{5{c}},{5{d}},{5{e}}}```，abcdeabcdeabcdeabcdeabcde可以寫成```{5{a,b,c,d,e}}```。
```verilog
module top_module (
    input a, b, c, d, e,
    output [24:0] out );//
    assign out = ~({ { 5{a} },{5{b}},{5{c}},{5{d}},{5{e}}} ^ {5{a,b,c,d,e}});
endmodule
```
---

### Modules: Hierarchy
#### Modules
Website: <a href="https://hdlbits.01xz.net/wiki/Module" target="_blank">https://hdlbits.01xz.net/wiki/Module</a>

這題在教如何引用module。
```verilog
module top_module ( input a, input b, output out );
    mod_a moda(.out(out),.in1(a),.in2(b));
endmodule
```
---
#### Connecting ports by position
Website: <a href="https://hdlbits.01xz.net/wiki/Module_pos" target="_blank">https://hdlbits.01xz.net/wiki/Module_pos</a>

這題跟上題差不多，題目要求我們照著argument的位置接線。
```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    module mod_a ( out1, out2, a, b, c, d );
endmodule
```
---
#### Connecting ports by name
Website: <a href="https://hdlbits.01xz.net/wiki/Module_name" target="_blank">https://hdlbits.01xz.net/wiki/Module_name</a>

這題跟上題差不多，只是上題是要求根據argument的位置接線，這題是要求跟據argument的名字接線。
```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a moda(.out1(out1), .out2(out2), .in1(a), .in2(b), .in3(c), .in4(d));
endmodule
```
---
#### Three modules
Website: <a href="https://hdlbits.01xz.net/wiki/Module_shift" target="_blank">https://hdlbits.01xz.net/wiki/Module_shift</a>

這題是練習用接線的方式，將3個dff串接在一起。
```verilog
module top_module ( input clk, input d, output q );
    wire q1,q2;
    my_dff dff1( .clk(clk), .d(d), .q(q1));
    my_dff dff2( .clk(clk), .d(q1), .q(q2));
    my_dff dff3( .clk(clk), .d(q2), .q(q));
endmodule
```
---
#### Modules and vectors
Website: <a href="https://hdlbits.01xz.net/wiki/Module_shift8" target="_blank">https://hdlbits.01xz.net/wiki/Module_shift8</a>

這題跟上題差不多，只是後面多接了一個multiplexer。而multiplexer可以用always block實現，速度會比用if else還快，而因為multiplexer是combinational logic，所以要用blocking assignments。

```verilog
module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    wire [7:0]q1,q2,q3;
    my_dff8 dff1( .clk(clk), .d(d), .q(q1));
    my_dff8 dff2( .clk(clk), .d(q1), .q(q2));
    my_dff8 dff3( .clk(clk), .d(q2), .q(q3));
    always @(*)
        case(sel)
            2'b00: q = d;
            2'b01: q = q1;
            2'b10: q = q2;
            2'b11: q = q3;
        endcase
endmodule
```
---
#### Adder 1
Website: <a href="https://hdlbits.01xz.net/wiki/Module_add" target="_blank">https://hdlbits.01xz.net/wiki/Module_add</a>

這題單純把兩個16bit adder接在一起，值得注意的是，如果argument不想接線，直接留空就行了。
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire c1;
    add16 add_1( .a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(c1));
    add16 add_2( .a(a[31:16]), .b(b[31:16]), .cin(c1), .sum(sum[31:16]), .cout());
endmodule
```
---
#### Adder 2
Website: <a href="hhttps://hdlbits.01xz.net/wiki/Module_fadd" target="_blank">https://hdlbits.01xz.net/wiki/Module_fadd</a>

這題跟上題差不多，只是要多寫一個1 bit full adder，可以用concatenation來實現。
```verilog
module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
	wire c1;
    add16 add_1( .a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(c1));
    add16 add_2( .a(a[31:16]), .b(b[31:16]), .cin(c1), .sum(sum[31:16]), .cout());
endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );
    assign {cout, sum} = a + b + cin;
endmodule
```
---
#### Carry-select adder
Website: <a href="https://hdlbits.01xz.net/wiki/Module_cseladd" target="_blank">https://hdlbits.01xz.net/wiki/Module_cseladd</a>

這題要我們接線CSA(carry-select adder)，CSA的好處在於已經偷算完cin是0和1的case，等到低位元進位後，就能馬上用multiplexer輸出算好的結果，缺點就是因為同時要算cin是0和1的結果，面積會變兩倍。
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);	
    wire sel;
    wire [15:0] s1,s2;
    add16 add1( .a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(sel));
    add16 add2( .a(a[31:16]), .b(b[31:16]), .cin(1'b0), .sum(s1), .cout());
    add16 add3( .a(a[31:16]), .b(b[31:16]), .cin(1'b1), .sum(s2), .cout());
    always @(*)
		case(sel)
        	1'b0: sum[31:16] = s1;
            1'b1: sum[31:16] = s2;
       	endcase
endmodule
```
---
#### Adder-subtractor
Website: <a href="https://hdlbits.01xz.net/wiki/Module_addsub" target="_blank">https://hdlbits.01xz.net/wiki/Module_addsub</a>

這題在教如何快速實現減法，也就是```a - b = a + ~(b) + 1```這件事。
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire c1;
    wire [31:0] b_xor;
    assign b_xor = b ^ {32{sub}};
    add16 add_1( .a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .sum(sum[15:0]), .cout(c1));
    add16 add_2( .a(a[31:16]), .b(b_xor[31:16]), .cin(c1), .sum(sum[31:16]), .cout());
endmodule
```
---
### Procedures
#### Always blocks (combinational)
Website: <a href="https://hdlbits.01xz.net/wiki/Alwaysblock1" target="_blank">https://hdlbits.01xz.net/wiki/Alwaysblock1</a>

這題在講說combinational logic可以有assign和always @(*)兩種寫法。然後有個細節要注意，assign的左值要用wire，always的左值要用reg，雖然這兩者在合成電路後沒差。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
	assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule
```
---
#### Always blocks (clocked)
Website: <a href="https://hdlbits.01xz.net/wiki/Alwaysblock2" target="_blank">https://hdlbits.01xz.net/wiki/Alwaysblock2</a>

這題就是在講combinational logic和sequential logic的差別。如果是clock always的話，最好賦值使用non-blocking。
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
	assign out_assign = a ^ b;
    always@(*)
        out_always_comb = a ^ b;
    always@(posedge clk)
        out_always_ff <= a ^ b;
endmodule
```
---